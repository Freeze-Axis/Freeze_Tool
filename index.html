<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Discord Bot Controller</title>
  <!-- Google Fonts: Roboto -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* リセット＆基本設定 */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; font-family: 'Roboto', sans-serif; }
    body { background: #121212; color: #e0e0e0; }

    /* アプリ全体のレイアウト：左サイドバー＋右メイン */
    #app {
      display: flex;
      height: 100vh;
    }
    /* サイドバー */
    #sidebar {
      width: 250px;
      background: #1f1f1f;
      padding: 20px;
      flex-shrink: 0;
    }
    #sidebar .logo {
      font-size: 1.8em;
      text-align: center;
      margin-bottom: 30px;
      color: #00c6ff;
    }
    #sidebar ul {
      list-style: none;
      padding: 0;
    }
    #sidebar ul li {
      margin-bottom: 20px;
    }
    #sidebar ul li a {
      text-decoration: none;
      color: #e0e0e0;
      font-size: 1.1em;
      transition: color 0.3s;
      cursor: pointer;
    }
    #sidebar ul li a:hover {
      color: #00c6ff;
    }
    
    /* メインコンテンツ */
    #main {
      flex: 1;
      padding: 20px 30px;
      overflow-y: auto;
      background: #181818;
    }
    /* 各セクションカード */
    .section-card {
      background: #1e1e1e;
      margin-bottom: 20px;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    .section-card h2 {
      margin-bottom: 15px;
      color: #00c6ff;
      border-bottom: 2px solid #00c6ff;
      padding-bottom: 5px;
    }
    
    /* フォーム要素 */
    label {
      display: block;
      margin-bottom: 5px;
      color: #00c6ff;
    }
    input[type="text"],
    input[type="number"],
    textarea,
    select {
      width: 100%;
      padding: 10px;
      border: 1px solid #00c6ff;
      border-radius: 4px;
      background: #2a2a2a;
      color: #e0e0e0;
      margin-bottom: 10px;
    }
    textarea { resize: vertical; }
    .checkbox-group {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .checkbox-group input[type="checkbox"] {
      margin-right: 10px;
    }
    .btn {
      padding: 12px 20px;
      background: #00c6ff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
      margin-right: 10px;
      margin-top: 10px;
    }
    .btn:hover { background: #0098d4; }
    .btn:disabled {
      background: #555;
      cursor: not-allowed;
    }
    
    /* ステータス表示エリア */
    .status-box {
      background: #1a1a1a;
      border: 1px solid #00c6ff;
      border-radius: 4px;
      padding: 15px;
      height: 150px;
      overflow-y: auto;
      white-space: pre-wrap;
      margin-top: 20px;
    }
    /* Tokenをマスクするためのクラス */
    .hidden-token { -webkit-text-security: disc; }
    
    /* リンククリック時にスムーズスクロール */
    html {
      scroll-behavior: smooth;
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- サイドバー -->
    <nav id="sidebar">
      <div class="logo">Discord Bot</div>
      <ul>
        <li><a data-target="botServer">Bot／サーバー</a></li>
        <li><a data-target="channel">チャンネル</a></li>
        <li><a data-target="message">メッセージ</a></li>
        <li><a data-target="userId">ユーザーID取得</a></li>
        <li><a data-target="poll">投票</a></li>
        <li><a data-target="other">その他</a></li>
        <li><a data-target="execution">実行／停止</a></li>
      </ul>
    </nav>
    <!-- メインエリア -->
    <div id="main">
      <form id="botForm">
        <!-- Bot／サーバー設定 -->
        <section id="botServer" class="section-card">
          <h2>Bot／サーバー設定</h2>
          <label for="token">Botトークン (1行につき1トークン)</label>
          <textarea id="token" name="token" rows="3" placeholder="TOKEN1&#10;TOKEN2" class="hidden-token"></textarea>
          <button type="button" class="btn" id="toggleTokenBtn">トークンを表示</button>
          <label for="serverId">サーバーID</label>
          <input type="text" id="serverId" name="serverId" placeholder="サーバーIDを入力">
        </section>
        
        <!-- チャンネル設定 -->
        <section id="channel" class="section-card">
          <h2>チャンネル設定</h2>
          <div class="checkbox-group">
            <input type="checkbox" id="sendToAllChannels" name="sendToAllChannels">
            <label for="sendToAllChannels">全チャンネルにランダム送信（自動取得）</label>
          </div>
          <div id="manualChannelDiv">
            <label for="channelIds">チャンネルID (手動入力・改行区切り)</label>
            <textarea id="channelIds" name="channelIds" rows="3" placeholder="全チャンネル送信がOFFの場合のみ有効"></textarea>
          </div>
        </section>
        
        <!-- メッセージ設定 -->
        <section id="message" class="section-card">
          <h2>メッセージ設定</h2>
          <label for="messageContent">メッセージ内容</label>
          <textarea id="messageContent" name="messageContent" rows="3" placeholder="送信するメッセージ"></textarea>
          <div class="checkbox-group">
            <input type="checkbox" id="appendRandomString" name="appendRandomString">
            <label for="appendRandomString">メッセージ末尾にランダム文字列追加</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="mentionRandomUsers" name="mentionRandomUsers">
            <label for="mentionRandomUsers">ランダムにメンション</label>
          </div>
          <label for="mentionCount">メンション数 (1～50)</label>
          <input type="number" id="mentionCount" name="mentionCount" min="1" max="50" value="1">
        </section>
        
        <!-- ユーザーID取得 -->
        <section id="userId" class="section-card">
          <h2>ユーザーID取得</h2>
          <label for="userIds">取得済みユーザーID</label>
          <textarea id="userIds" name="userIds" rows="3" placeholder="ここに取得したユーザーIDが表示されます"></textarea>
          <button type="button" class="btn" id="fetchUserIdsButton">ユーザーID取得</button>
        </section>
        
        <!-- 投票設定 -->
        <section id="poll" class="section-card">
          <h2>投票設定</h2>
          <div class="checkbox-group">
            <input type="checkbox" id="includePoll" name="includePoll">
            <label for="includePoll">投票を含む</label>
          </div>
          <div id="pollFields" style="display: none;">
            <label for="pollQuestion">投票タイトル</label>
            <input type="text" id="pollQuestion" name="pollQuestion" placeholder="投票のタイトルを入力">
            <label for="pollAnswers">投票の回答 (カンマ区切り)</label>
            <input type="text" id="pollAnswers" name="pollAnswers" placeholder="例: 回答1, 回答2, 回答3">
            <label for="pollDuration">開催期間 (時間)</label>
            <select id="pollDuration" name="pollDuration">
              <option value="1">1時間</option>
              <option value="4">4時間</option>
              <option value="8">8時間</option>
              <option value="24">24時間</option>
              <option value="72">3日間</option>
              <option value="168">1週間</option>
              <option value="336">2週間</option>
            </select>
            <div class="checkbox-group">
              <input type="checkbox" id="expirePoll" name="expirePoll">
              <label for="expirePoll">投票を即時終了</label>
            </div>
          </div>
        </section>
        
        <!-- その他設定 -->
        <section id="other" class="section-card">
          <h2>その他設定</h2>
          <label for="delay">送信間隔 (秒)</label>
          <input type="number" id="delay" name="delay" step="0.1" value="0.1" placeholder="例: 0.1">
        </section>
        
        <!-- 実行／停止 -->
        <section id="execution" class="section-card">
          <h2>実行／停止</h2>
          <button type="submit" class="btn" id="executeBtn">実行</button>
          <button type="button" class="btn" id="stopButton">停止</button>
        </section>
      </form>
      <!-- ステータス表示 -->
      <div id="status" class="status-box">処理待機中...</div>
    </div>
  </div>

  <!-- axios CDN -->
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script>
    // --- グローバル変数 ---
    let processRunning = false;
    let isStopped = false;
    let lastErrorMessage = "";

    // --- ローカルストレージによるフォーム状態保存 ---
    document.addEventListener("DOMContentLoaded", function () {
      const form = document.getElementById("botForm");
      function saveFormData() {
        const formData = {};
        new FormData(form).forEach((value, key) => { formData[key] = value; });
        localStorage.setItem("botFormData", JSON.stringify(formData));
      }
      function loadFormData() {
        const saved = localStorage.getItem("botFormData");
        if (saved) {
          const data = JSON.parse(saved);
          Object.keys(data).forEach(key => {
            if (form.elements[key]) {
              if (form.elements[key].type === "checkbox") {
                form.elements[key].checked = data[key] === "on";
              } else {
                form.elements[key].value = data[key];
              }
            }
          });
        }
      }
      form.addEventListener("input", saveFormData);
      loadFormData();

      // 「全チャンネル送信」チェックON時、手動入力欄を非表示
      const sendAllCheckbox = document.getElementById("sendToAllChannels");
      const manualChannelDiv = document.getElementById("manualChannelDiv");
      function updateChannelInput() {
        manualChannelDiv.style.display = sendAllCheckbox.checked ? "none" : "block";
      }
      sendAllCheckbox.addEventListener("change", updateChannelInput);
      updateChannelInput();

      // 投票チェックの状態に応じて投票設定フィールドの表示を更新（リロード時も反映）
      const includePollCheckbox = document.getElementById("includePoll");
      const pollFields = document.getElementById("pollFields");
      pollFields.style.display = includePollCheckbox.checked ? "block" : "none";

      // 初期状態：停止ボタンは無効化
      document.getElementById("stopButton").disabled = true;
    });

    // --- サイドバーメニュークリックで対象セクションへスクロール ---
    document.querySelectorAll("#sidebar ul li a").forEach(link => {
      link.addEventListener("click", function() {
        const targetId = this.getAttribute("data-target");
        const targetEl = document.getElementById(targetId);
        if (targetEl) {
          targetEl.scrollIntoView({ behavior: "smooth" });
        }
      });
    });

    // --- Token表示／非表示切替 ---
    document.getElementById("toggleTokenBtn").addEventListener("click", function() {
      const tokenField = document.getElementById("token");
      if (tokenField.classList.contains("hidden-token")) {
        tokenField.classList.remove("hidden-token");
        this.textContent = "トークンを隠す";
      } else {
        tokenField.classList.add("hidden-token");
        this.textContent = "トークンを表示";
      }
    });

    // --- 投票項目表示切替 ---
    document.getElementById("includePoll").addEventListener("change", function() {
      const pollFields = document.getElementById("pollFields");
      pollFields.style.display = this.checked ? "block" : "none";
    });

    // --- ステータス更新 ---
    function updateStatus(message, isError = false) {
      if (message === lastErrorMessage) return;
      lastErrorMessage = message;
      const statusEl = document.getElementById("status");
      const div = document.createElement("div");
      div.innerText = message;
      div.style.color = isError ? "red" : "white";
      statusEl.appendChild(div);
    }

    // --- ランダム文字列生成 ---
    function generateRandomString(length) {
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      let result = "";
      for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }

    // --- リトライ処理 ---
    async function retryRequest(requestFunc, delay = 1000) {
      while (true) {
        try {
          return await requestFunc();
        } catch (error) {
          if (error.response && error.response.status === 429) {
            const retryAfter = error.response.data.retry_after || delay / 1000;
            updateStatus(`レート制限: ${retryAfter}秒後に再試行`, true);
            await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
          } else if (error.message === "Network Error") {
            updateStatus("ネットワークエラー。再試行します。", true);
            await new Promise(resolve => setTimeout(resolve, delay));
          } else {
            updateStatus(`エラー: ${error.message}`, true);
            throw error;
          }
        }
      }
    }

    // --- 通常メッセージ送信用 ---
    async function sendMessageToChannels(message, channelIds, token) {
      const headers = { Authorization: token, "Content-Type": "application/json" };
      for (const channelId of channelIds) {
        try {
          const data = { content: message };
          await retryRequest(() => axios.post(`https://discord.com/api/v10/channels/${channelId}/messages`, data, { headers }));
        } catch (error) {
          // エラーは retryRequest 内で処理
        }
      }
    }

    // --- 投票送信用 ---
    async function sendPollData(pollData, channelIds, token) {
      const headers = { Authorization: token, "Content-Type": "application/json" };
      for (const channelId of channelIds) {
        try {
          const response = await retryRequest(() => axios.post(`https://discord.com/api/v10/channels/${channelId}/messages`, pollData, { headers }));
          if (response && response.data) return response;
          else throw new Error("無効なレスポンス");
        } catch (error) {
          // エラーは updateStatus 内で表示
        }
      }
    }

    // --- 「ユーザーID取得」ボタン処理 ---
    document.getElementById("fetchUserIdsButton").addEventListener("click", async function () {
      const serverId = document.getElementById("serverId").value.trim();
      const token = document.getElementById("token").value.split("\n")[0].trim();
      const sendToAll = document.getElementById("sendToAllChannels").checked;
      if (!serverId) { updateStatus("サーバーIDを入力してください。", true); return; }
      if (!token) { updateStatus("Botトークンを入力してください。", true); return; }
      
      let channelIds = [];
      if (sendToAll) {
        try {
          const resp = await retryRequest(() =>
            axios.get(`https://discord.com/api/v9/guilds/${serverId}/channels`, {
              headers: { Authorization: token }
            })
          );
          const allChannels = resp.data.filter(ch => [0, 2, 5].includes(ch.type));
          if (allChannels.length === 0) { updateStatus("送信可能なチャンネルが見つかりません。", true); return; }
          channelIds = allChannels.map(ch => ch.id);
        } catch (error) {
          updateStatus(`チャンネル取得エラー: ${error.message}`, true);
          return;
        }
      } else {
        const channelIdsText = document.getElementById("channelIds").value.trim();
        if (!channelIdsText) { updateStatus("チャンネルIDを入力してください。", true); return; }
        channelIds = channelIdsText.split("\n").map(id => id.trim()).filter(id => id);
      }
      
      const userIdSet = new Set();
      const validChannelIds = [];
      // 各チャンネルからメッセージ取得
      for (const channelId of channelIds) {
        try {
          const response = await retryRequest(() => axios.get(`https://discord.com/api/v10/channels/${channelId}/messages?limit=100`, { headers: { Authorization: token } }));
          const messages = response.data;
          messages.forEach(msg => { if (msg.author && msg.author.id) userIdSet.add(msg.author.id); });
          validChannelIds.push(channelId);
        } catch (error) {
          updateStatus(`チャンネル ${channelId} のユーザーID取得エラー: ${error.message} （取得対象から除外します）`, true);
        }
      }
      if (sendToAll) {
        updateStatus(`有効なチャンネル: ${validChannelIds.join(", ")}`);
      }
      const userIds = Array.from(userIdSet);
      document.getElementById("userIds").value = userIds.join("\n");
      updateStatus(`ユーザーID ${userIds.length} 件取得しました。`);
    });

    // --- フォーム送信時の処理 ---
    document.getElementById("botForm").addEventListener("submit", async function (event) {
      event.preventDefault();
      if (processRunning) return;
      processRunning = true;
      isStopped = false;
  
      // ボタンの状態更新：実行ボタン無効、停止ボタン有効
      const execBtn = document.getElementById("executeBtn");
      const stopBtn = document.getElementById("stopButton");
      execBtn.disabled = true;
      stopBtn.disabled = false;
  
      const tokens = document.getElementById("token").value.split("\n").map(t => t.trim()).filter(t => t);
      const serverId = document.getElementById("serverId").value.trim();
      const baseMessage = document.getElementById("messageContent").value;
      const delay = (parseFloat(document.getElementById("delay").value) || 0.1) * 1000;
      const appendRandomString = document.getElementById("appendRandomString").checked;
      const mentionRandomUsers = document.getElementById("mentionRandomUsers").checked;
      let mentionCount = parseInt(document.getElementById("mentionCount").value, 10) || 1;
      mentionCount = Math.min(Math.max(mentionCount, 1), 50);
      
      // 投票関連の値（「投票を含む」チェックがONの場合のみ使用）
      const includePoll = document.getElementById("includePoll").checked;
      const pollQuestion = document.getElementById("pollQuestion").value;
      const pollAnswers = document.getElementById("pollAnswers").value.split(",").map(a => a.trim()).filter(a => a);
      const pollDuration = document.getElementById("pollDuration").value;
      const expirePoll = document.getElementById("expirePoll").checked;
  
      const sendToAllChannels = document.getElementById("sendToAllChannels").checked;
      const manualChannelsText = document.getElementById("channelIds").value.trim();
      const userIdsText = document.getElementById("userIds").value.trim();
  
      let channelsList = [];
      if (sendToAllChannels) {
        try {
          const resp = await retryRequest(() =>
            axios.get(`https://discord.com/api/v9/guilds/${serverId}/channels`, {
              headers: { Authorization: tokens[0] }
            })
          );
          const allChannels = resp.data.filter(ch => [0, 2, 5].includes(ch.type)).map(ch => ch.id);
          if (allChannels.length === 0) { updateStatus("送信可能なチャンネルが見つかりません。", true); processRunning = false; return; }
          channelsList = allChannels;
        } catch (error) {
          updateStatus(`チャンネル取得エラー: ${error.message}`, true);
          processRunning = false;
          return;
        }
      } else {
        const manualIds = manualChannelsText.split("\n").map(id => id.trim()).filter(id => id);
        if (manualIds.length === 0) { updateStatus("チャンネルIDが入力されていません。", true); processRunning = false; return; }
        channelsList = manualIds;
      }
  
      document.getElementById("status").innerText = "処理中...";
      let tokenIndex = 0;
      while (!isStopped) {
        let finalMessage = baseMessage;
        if (mentionRandomUsers) {
          if (userIdsText) {
            const userIds = userIdsText.split("\n").map(id => id.trim()).filter(id => id);
            if (userIds.length === 0) { updateStatus("ユーザーID欄が空です。", true); }
            else {
              const effectiveCount = Math.min(mentionCount, userIds.length);
              const shuffled = userIds.slice().sort(() => 0.5 - Math.random());
              const selected = shuffled.slice(0, effectiveCount);
              const mentions = selected.map(id => `<@${id}>`);
              const lines = [];
              for (let i = 0; i < mentions.length; i += 3) {
                lines.push(mentions.slice(i, i + 3).join(" "));
              }
              finalMessage += "\n" + lines.join("\n");
            }
          } else {
            try {
              const resp = await retryRequest(() =>
                axios.get(`https://discord.com/api/v9/guilds/${serverId}/members`, {
                  headers: { Authorization: tokens[tokenIndex] }
                })
              );
              const members = resp.data;
              if (members.length < 3) { updateStatus("ギルドメンバーが不足しています。", true); }
              else {
                const shuffled = members.slice().sort(() => 0.5 - Math.random());
                const selected = shuffled.slice(0, 3).map(m => `<@${m.user.id}>`);
                finalMessage += "\n" + selected.join(" ");
              }
            } catch (error) {
              updateStatus(`ギルドメンバー取得エラー: ${error.message}`, true);
            }
          }
        }
        if (appendRandomString) { finalMessage += " " + generateRandomString(8); }
  
        let pollData = null;
        if (includePoll) {
          if (pollQuestion && pollAnswers.length > 0) {
            pollData = {
              content: finalMessage,
              poll: {
                question: { text: pollQuestion },
                answers: pollAnswers.map(answer => ({ poll_media: { text: answer } })),
                duration: pollDuration
              },
              flags: 0
            };
          }
        }
  
        let targetChannels = [];
        if (sendToAllChannels) {
          const randomIndex = Math.floor(Math.random() * channelsList.length);
          targetChannels.push(channelsList[randomIndex]);
        } else {
          const randomIndex = Math.floor(Math.random() * channelsList.length);
          targetChannels.push(channelsList[randomIndex]);
        }
  
        try {
          if (pollData) {
            const pollResp = await retryRequest(() =>
              sendPollData(pollData, targetChannels, tokens[tokenIndex])
            );
            updateStatus("メッセージ＋投票を送信しました。");
            if (expirePoll && pollResp && pollResp.data) {
              const pollId = pollResp.data.id;
              const channelId = pollResp.data.channel_id;
              await retryRequest(() =>
                axios.post(`https://discord.com/api/v9/channels/${channelId}/polls/${pollId}/expire`, {}, { headers: { Authorization: tokens[tokenIndex] } })
              );
              updateStatus("投票を即時終了しました。");
            }
          } else {
            await retryRequest(() =>
              sendMessageToChannels(finalMessage, targetChannels, tokens[tokenIndex])
            );
            updateStatus("メッセージを送信しました。");
          }
        } catch (error) {
          updateStatus(`送信エラー: ${error.message}`, true);
        }
        tokenIndex = (tokenIndex + 1) % tokens.length;
        await new Promise(resolve => setTimeout(resolve, delay));
      }
      updateStatus("メッセージ送信が停止しました。");
      processRunning = false;
      // プロセス停止時：実行ボタン有効、停止ボタン無効
      execBtn.disabled = false;
      stopBtn.disabled = true;
    });
  
    // --- 停止ボタン ---
    document.getElementById("stopButton").addEventListener("click", function () {
      isStopped = true;
      updateStatus("処理を停止しました。");
      processRunning = false;
      // ボタン状態更新：実行ボタン有効、停止ボタン無効
      document.getElementById("executeBtn").disabled = false;
      this.disabled = true;
    });
  </script>
</body>
</html>
